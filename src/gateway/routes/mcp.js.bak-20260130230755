/**
 * MCP Gateway Route
 * - Enforces Accept header requirements for StreamableHTTP (SSE)
 * - Proxies requests to MCP handler
 * - Forces chunked transfer by stripping Content-Length (upstream may set it)
 */

const express = require('express');
const router = express.Router();
const mcpHandler = require('../../mcp/handler');
const { requiredScopesForTool, hasRequiredScopes } = require('../oauth/scopePolicy');
const { buildWwwAuthenticate } = require('../oauth/wwwAuthenticate');
const { securitySchemesForTool } = require('../../mcp/toolAuth');

function hasRequiredAccept(req) {
  const accept = String(req.headers['accept'] || '').toLowerCase();
  if (!accept || accept.includes('*/*')) return true;
  return accept.includes('application/json') && accept.includes('text/event-stream');
}

function notAcceptable(res) {
  // Keep it JSON (not SSE) so curl/jq can read the error cleanly
  return res.status(406).json({
    jsonrpc: '2.0',
    error: {
      code: -32000,
      message: 'Not Acceptable: Client must accept both application/json and text/event-stream'
    },
    id: null
  });
}

  // Workaround: inject tool.securitySchemes into tools/list SSE payload
  function enableToolsListSecuritySchemesInjection(res) {
    let buffer = '';
    const origWrite = res.write.bind(res);
    const origEnd = res.end.bind(res);

    function chunkToString(chunk) {
      if (chunk == null) return '';
      if (Buffer.isBuffer(chunk)) return chunk.toString('utf8');
      if (ArrayBuffer.isView(chunk)) {
        return Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength).toString('utf8');
      }
      if (chunk instanceof ArrayBuffer) return Buffer.from(chunk).toString('utf8');
      return String(chunk);
    }

    function transformEvent(evt) {
      try {
        const lines = evt.split(/\r?\n/);
        const out = [];
        const dataParts = [];
        for (const ln of lines) {
          if (ln.startsWith('data:')) dataParts.push(ln.replace(/^data:\s?/, ''));
          else if (ln.length) out.push(ln);
        }
        if (!dataParts.length) return evt;

        const raw = dataParts.join('\n');
        const obj = JSON.parse(raw);
        const tools = obj && obj.result && obj.result.tools;
        if (Array.isArray(tools)) {
          for (const t of tools) {
            if (t && t.name && t.securitySchemes == null) {
              try { t.securitySchemes = securitySchemesForTool(t.name); } catch (_) {}
            }
          }
        }

        out.push('data: ' + JSON.stringify(obj));
        out.push('');
        return out.join('\n') + '\n';
      } catch (_) {
        return evt;
      }
    }

    function flushCompleteEvents() {
      const parts = buffer.split(/\n\n/);
      buffer = parts.pop() || '';
      for (const part of parts) {
        origWrite(transformEvent(part + '\n\n'));
      }
    }

    res.write = (chunk, encoding, cb) => {
      if (typeof encoding === 'function') { cb = encoding; encoding = undefined; }
      buffer += chunkToString(chunk);
      flushCompleteEvents();
      if (typeof cb === 'function') cb();
      return true;
    };

    res.end = (chunk, encoding, cb) => {
      if (typeof chunk === 'function') { cb = chunk; chunk = undefined; encoding = undefined; }
      else if (typeof encoding === 'function') { cb = encoding; encoding = undefined; }
      if (chunk) buffer += chunkToString(chunk);
      if (buffer.length) origWrite(transformEvent(buffer));
      buffer = '';
      return origEnd(undefined, encoding, cb);
    };
  }


/**
 * Force "chunked" behavior for SSE by preventing Content-Length from being set.
 * Some upstream libs build the whole body and try to set Content-Length; this breaks
 * the expected "streaming" feel and can confuse proxies/clients.
 */
function forceChunkedSSE(res) {
  // Block any future Content-Length header attempts
  const origSetHeader = res.setHeader.bind(res);
  res.setHeader = (name, value) => {
    const key = String(name || '').toLowerCase();
    if (key === 'content-length') return;
    return origSetHeader(name, value);
  };

  // Intercept writeHead so we can delete Content-Length even if passed in headers
  const origWriteHead = res.writeHead.bind(res);
  res.writeHead = (statusCode, reasonPhrase, headers) => {
    let rp = reasonPhrase;
    let h = headers;

    // Node allows writeHead(status, headers)
    if (typeof rp === 'object' && rp !== null) {
      h = rp;
      rp = undefined;
    }

    // Remove content-length from header object if present
    if (h && typeof h === 'object') {
      for (const k of Object.keys(h)) {
        if (String(k).toLowerCase() === 'content-length') {
          delete h[k];
        }
      }
    }

    // Remove any already-set Content-Length and ensure chunked
    try { res.removeHeader('Content-Length'); } catch (_) {}
    try { origSetHeader('Transfer-Encoding', 'chunked'); } catch (_) {}

    // Continue with original writeHead
    if (rp !== undefined) return origWriteHead(statusCode, rp, h);
    return origWriteHead(statusCode, h);
  };
}

router.all('/', async (req, res) => {
  // Only allow MCP methods (match your root doc)
  if (!['POST', 'GET', 'DELETE', 'HEAD', 'OPTIONS'].includes(req.method)) {
    return res.status(405).json({
      error: 'Method Not Allowed',
      allowed: ['POST', 'GET', 'DELETE', 'HEAD', 'OPTIONS']
    });
  }
    // Connection probes (ChatGPT Desktop does GET/HEAD/OPTIONS during setup)

  if (req.method === 'OPTIONS') {

    res.setHeader('Allow', 'POST, GET, DELETE, HEAD, OPTIONS');

    res.setHeader('Access-Control-Allow-Methods', 'POST, GET, DELETE, HEAD, OPTIONS');

    res.setHeader('Access-Control-Allow-Headers', 'Authorization, Content-Type, Accept');

    return res.status(204).end();

  }

  if (req.method === 'HEAD') {

    return res.status(200).end();

  }

  if (req.method === 'GET') {

    return res.status(200).json({

      ok: true,

      endpoint: '/mcp',

      transport: 'streamable-http'

    });

  }



  // Enforce required Accept header for StreamableHTTP transport
  if (req.method === 'POST' && !hasRequiredAccept(req)) {
    return notAcceptable(res);
  }

  // Auth gate: tools/call requires OAuth scopes (or PAT * )
  const body = req.body;

  // Support JSON-RPC batch (array) and single-object requests
  const requests = Array.isArray(body) ? body : [body];

  if (req.method === 'POST') {
    const toolCalls = requests.filter((r) => r && r.method === 'tools/call');

    if (toolCalls.length) {
      const requiredSet = new Set();
      for (const r of toolCalls) {
        const toolName = r?.params?.name;
        for (const sc of requiredScopesForTool(toolName)) requiredSet.add(sc);
      }
      const required = Array.from(requiredSet);

      if (required.length && !hasRequiredScopes(req.auth, required)) {
        const scopeStr = required.join(' ');

        const base = String(process.env.OAUTH_RESOURCE || '').replace(/\/+$/, '');
        const proto = String(req.headers['x-forwarded-proto'] || req.protocol || 'https').split(',')[0].trim();
        const host = req.get('host');
        const resourceMetadataUrl = base
          ? `${base}/.well-known/oauth-protected-resource`
          : `${proto}://${host}/.well-known/oauth-protected-resource`;

        const isLoggedIn = !!req.auth;
        const challenge = buildWwwAuthenticate({
          resourceMetadataUrl,
          scope: scopeStr,
          error: isLoggedIn ? 'insufficient_scope' : 'invalid_token',
          errorDescription: isLoggedIn
            ? `Missing required scope: ${scopeStr}`
            : 'Authorization required. Please connect your account.'
        });

        res.setHeader('WWW-Authenticate', challenge);

        // Important: use HTTP 401 so ChatGPT Desktop triggers "Connect account"/reauth.
        return res.status(401).json({
          jsonrpc: '2.0',
          id: Array.isArray(body) ? null : (body.id ?? null),
          result: {
            isError: true,
            content: [
              {
                type: 'text',
                text: isLoggedIn
                  ? `Missing required scope: ${scopeStr}`
                  : 'Authorization required. Please connect your account.'
              }
            ],
            _meta: {
              'mcp/www_authenticate': challenge
            }
          }
        });
      }
    }
  }

  // IMPORTANT: Do not eagerly write headers here (avoid ERR_HTTP_HEADERS_SENT).
  // Instead, patch header writing to prevent Content-Length and force chunked.
  forceChunkedSSE(res);

    // tools/list: inject securitySchemes into SSE payload
    if (req.method === 'POST') {
      const b = req.body;
      const isToolsList = Array.isArray(b)
        ? b.some((r) => r && r.method === 'tools/list')
        : (b && b.method === 'tools/list');
      if (isToolsList) enableToolsListSecuritySchemesInjection(res);
    }


  try {
    // Express json middleware already parsed body for POST
    await mcpHandler.handleRequest(req, res, req.body);
  } catch (err) {
    if (res.headersSent) {
      try { res.end(); } catch (_) {}
      return;
    }
    return res.status(500).json({
      jsonrpc: '2.0',
      error: { code: -32000, message: `Internal error: ${err.message}` },
      id: null
    });
  }
});

module.exports = router;
